{"version":3,"file":"index.js","sources":["../node_modules/devlop/lib/default.js","../node_modules/longest-streak/index.js","../node_modules/mdast-util-math/lib/index.js","../node_modules/micromark-util-character/index.js","../node_modules/micromark-factory-space/index.js","../node_modules/micromark-extension-math/lib/math-flow.js","../node_modules/micromark-extension-math/lib/math-text.js","../node_modules/micromark-extension-math/lib/syntax.js","../node_modules/remark-math/lib/index.js","../node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit-parents/lib/color.js","../node_modules/unist-util-visit-parents/lib/index.js","../node_modules/unist-util-visit/lib/index.js","../src/remark-math-to-code.js","../src/index.js"],"sourcesContent":["export function deprecate(fn) {\n  return fn\n}\n\nexport function equal() {}\n\nexport function ok() {}\n\nexport function unreachable() {}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('../index.js').InlineMath} InlineMath\n * @typedef {import('../index.js').Math} Math\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {ok as assert} from 'devlop'\nimport {longestStreak} from 'longest-streak'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    /** @type {HastElement} */\n    const code = {\n      type: 'element',\n      tagName: 'code',\n      properties: {className: ['language-math', 'math-display']},\n      children: []\n    }\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {hName: 'pre', hChildren: [code]}\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.data.mathFlowInside) return\n    this.buffer()\n    this.data.mathFlowInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    this.exit(token)\n    node.value = data\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    const code = /** @type {HastElement} */ (node.data.hChildren[0])\n    assert(code.type === 'element')\n    assert(code.tagName === 'code')\n    code.children.push({type: 'text', value: data})\n    this.data.mathFlowInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'code',\n          hProperties: {className: ['language-math', 'math-inline']},\n          hChildren: []\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'inlineMath')\n    this.exit(token)\n    node.value = data\n    const children = /** @type {Array<HastElementContent>} */ (\n      // @ts-expect-error: we defined it in `enterMathFlow`.\n      node.data.hChildren\n    )\n    children.push({type: 'text', value: data})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, state, info) {\n    const raw = node.value || ''\n    const tracker = state.createTracker(info)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = state.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = state.enter('mathFlowMeta')\n      value += tracker.move(\n        state.safe(node.meta, {\n          after: '\\n',\n          before: value,\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  function inlineMath(node, _, state) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index]\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      const expression = state.compilePattern(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownSpace} from 'micromark-util-character'\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `␉` represents a tab (plus how much it expands) and `␠` represents a\n * single space.\n *\n * ```markdown\n * ␉\n * ␠␠␠␠\n * ␉␠\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns {State}\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  return start\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n    if (sizeOpen < 2) {\n      return nok(code)\n    }\n    effects.exit('mathFlowFenceSequence')\n    return factorySpace(effects, metaBefore, 'whitespace')(code)\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code)\n    }\n    effects.enter('mathFlowFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('mathFlowFenceMeta')\n      return metaAfter(code)\n    }\n    if (code === 36) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence')\n    if (self.interrupt) {\n      return ok(code)\n    }\n    return effects.attempt(\n      nonLazyContinuation,\n      beforeNonLazyContinuation,\n      after\n    )(code)\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt(\n      {\n        tokenize: tokenizeClosingFence,\n        partial: true\n      },\n      after,\n      contentStart\n    )(code)\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (\n      initialSize\n        ? factorySpace(\n            effects,\n            beforeContentChunk,\n            'linePrefix',\n            initialSize + 1\n          )\n        : beforeContentChunk\n    )(code)\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code)\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeNonLazyContinuation,\n        after\n      )(code)\n    }\n    effects.enter('mathFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return beforeContentChunk(code)\n    }\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(\n      effects,\n      beforeSequenceClose,\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return sequenceClose(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n      if (size < sizeOpen) {\n        return nok(code)\n      }\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, afterSequenceClose, 'whitespace')(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code)\n    }\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can use two or more dollars for text math.\n\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport {markdownLineEnding} from 'micromark-util-character'\n/**\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Construct}\n *   Construct.\n */\nexport function mathText(options) {\n  const options_ = options || {}\n  let single = options_.singleDollarTextMath\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this\n    let sizeOpen = 0\n    /** @type {number} */\n    let size\n    /** @type {Token} */\n    let token\n    return start\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText')\n      effects.enter('mathTextSequence')\n      return sequenceOpen(code)\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code)\n        sizeOpen++\n        return sequenceOpen\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code)\n      }\n      effects.exit('mathTextSequence')\n      return between(code)\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code)\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence')\n        size = 0\n        return sequenceClose(code)\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space')\n        effects.consume(code)\n        effects.exit('space')\n        return between\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        return between\n      }\n\n      // Data.\n      effects.enter('mathTextData')\n      return data(code)\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (\n        code === null ||\n        code === 32 ||\n        code === 36 ||\n        markdownLineEnding(code)\n      ) {\n        effects.exit('mathTextData')\n        return between(code)\n      }\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code)\n        size++\n        return sequenceClose\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence')\n        effects.exit('mathText')\n        return ok(code)\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData'\n      return data(code)\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n  let index\n  /** @type {number | undefined} */\n  let enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding'\n        events[headEnterIndex][1].type = 'mathTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'mathTextData'\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n      enter = undefined\n    }\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 36 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('./math-text.js').Options} Options\n */\n\nimport {mathFlow} from './math-flow.js'\nimport {mathText} from './math-text.js'\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  }\n}\n","/// <reference types=\"mdast-util-math\" />\n/// <reference types=\"remark-parse\" />\n/// <reference types=\"remark-stringify\" />\n\n/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n * @typedef {import('unified').Processor<Root>} Processor\n */\n\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\nimport {math} from 'micromark-extension-math'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Add support for math.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport default function remarkMath(options) {\n  // @ts-expect-error: TS is wrong about `this`.\n  // eslint-disable-next-line unicorn/no-this-assignment\n  const self = /** @type {Processor} */ (this)\n  const settings = options || emptyOptions\n  const data = self.data()\n\n  const micromarkExtensions =\n    data.micromarkExtensions || (data.micromarkExtensions = [])\n  const fromMarkdownExtensions =\n    data.fromMarkdownExtensions || (data.fromMarkdownExtensions = [])\n  const toMarkdownExtensions =\n    data.toMarkdownExtensions || (data.toMarkdownExtensions = [])\n\n  micromarkExtensions.push(math(settings))\n  fromMarkdownExtensions.push(mathFromMarkdown())\n  toMarkdownExtensions.push(mathToMarkdown(settings))\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node’s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > 👉 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn’t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn’t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isn’t a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when it’s released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > 👉 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn’t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn’t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n","import { visit } from 'unist-util-visit'\n\nexport const remarkMath2Code = () => {\n  return tree => {\n    visit(tree, { type: 'math' }, element => {\n      element.type = 'code'\n      element.lang = 'math'\n      element.data.hChildren = undefined\n      element.data.hName = undefined\n      element.data.hProperties = {\n        lang: 'math'\n      }\n    })\n    visit(tree, { type: 'inlineMath' }, element => {\n      element.type = 'inlineCode'\n      element.lang = 'inline_math'\n      element.data.hChildren = undefined\n      element.data.hName = undefined\n      element.data.hProperties = {\n        lang: 'inline_math'\n      }\n    })\n  }\n}\n","import { markdownRenderer, CodeMirror } from 'inkdrop'\nimport { lazy } from 'react'\nimport remarkMath from 'remark-math'\nimport { remarkMath2Code } from './remark-math-to-code'\n\nconsole.log('module.paths:', module.paths)\n\nconst MATH_MODE_INFO = {\n  name: 'math',\n  mime: 'text/x-latex',\n  mode: 'stex',\n  ext: [],\n  alias: ['inline_math']\n}\n\nconst ReactMath = lazy(() => import('./react-math'))\n\nmodule.exports = {\n  activate() {\n    if (markdownRenderer) {\n      markdownRenderer.remarkPlugins.push(remarkMath)\n      markdownRenderer.remarkPlugins.push(remarkMath2Code)\n      markdownRenderer.remarkCodeComponents.math = ReactMath\n      markdownRenderer.remarkCodeComponents.inline_math = ReactMath\n    }\n    if (CodeMirror) {\n      CodeMirror.modeInfo.push(MATH_MODE_INFO)\n    }\n  },\n\n  deactivate() {\n    if (markdownRenderer) {\n      markdownRenderer.remarkPlugins = markdownRenderer.remarkPlugins.filter(\n        plugin => remarkMath !== plugin\n      )\n      markdownRenderer.remarkPlugins = markdownRenderer.remarkPlugins.filter(\n        plugin => ![remarkMath, remarkMath2Code].includes(plugin)\n      )\n      markdownRenderer.remarkCodeComponents.math = null\n      markdownRenderer.remarkCodeComponents.inline_math = null\n    }\n    if (CodeMirror) {\n      const { modeInfo } = CodeMirror\n      const i = modeInfo.indexOf(MATH_MODE_INFO)\n      if (i >= 0) modeInfo.splice(i, 1)\n    }\n  }\n}\n"],"names":["ok","longestStreak","value","substring","source","String","index","indexOf","expected","count","max","TypeError","length","mathFromMarkdown","enter","mathFlow","enterMathFlow","mathFlowFenceMeta","enterMathFlowMeta","mathText","enterMathText","exit","exitMathFlow","mathFlowFence","exitMathFlowFence","exitMathFlowMeta","mathFlowValue","exitMathData","exitMathText","mathTextData","token","code","type","tagName","properties","className","children","meta","data","hName","hChildren","buffer","resume","node","stack","assert","mathFlowInside","replace","push","undefined","hProperties","config","call","mathToMarkdown","options","single","singleDollarTextMath","inlineMath","peek","inlineMathPeek","unsafe","character","inConstruct","after","atBreak","handlers","math","_","state","info","raw","tracker","createTracker","sequence","repeat","Math","move","subexit","safe","before","encode","current","size","RegExp","test","pattern","expression","compilePattern","match","exec","position","codePointAt","slice","markdownLineEnding","markdownSpace","factorySpace","effects","limit","Number","POSITIVE_INFINITY","start","prefix","consume","tokenize","tokenizeMathFenced","concrete","nonLazyContinuation","tokenizeNonLazyContinuation","partial","nok","self","tail","events","initialSize","sliceSerialize","sizeOpen","sequenceOpen","metaBefore","metaAfter","contentType","interrupt","attempt","beforeNonLazyContinuation","tokenizeClosingFence","contentStart","beforeContentChunk","contentChunk","beforeSequenceClose","parser","constructs","disable","null","includes","sequenceClose","afterSequenceClose","lineStart","lazy","now","line","options_","tokenizeMathText","resolve","resolveMathText","previous","between","tailExitIndex","headEnterIndex","end","splice","flow","text","emptyOptions","remarkMath","settings","micromarkExtensions","fromMarkdownExtensions","toMarkdownExtensions","convert","castFactory","Array","isArray","anyFactory","propsFactory","typeFactory","Error","tests","checks","any","parameters","apply","check","checkAsRecord","all","nodeAsRecord","key","testFunction","parent","Boolean","looksLikeANode","color","d","empty","CONTINUE","EXIT","SKIP","visitParents","tree","visitor","reverse","is","step","factory","parents","name","Object","defineProperty","visit","result","subresult","offset","grandparents","toResult","nodeAsParent","concat","child","testOrVisitor","visitorOrReverse","maybeReverse","overload","remarkMath2Code","element","lang","console","log","module","paths","MATH_MODE_INFO","mime","mode","ext","alias","ReactMath","exports","activate","markdownRenderer","remarkPlugins","remarkCodeComponents","inline_math","CodeMirror","modeInfo","deactivate","filter","plugin","i"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12]}