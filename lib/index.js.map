{"version":3,"file":"index.js","sources":["../node_modules/micromark-util-character/index.js","../node_modules/micromark-factory-space/index.js","../node_modules/micromark-extension-math/lib/math-flow.js","../node_modules/micromark-extension-math/lib/math-text.js","../node_modules/micromark-extension-math/lib/syntax.js","../node_modules/longest-streak/index.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/mdast-util-to-markdown/lib/util/safe.js","../node_modules/mdast-util-to-markdown/lib/util/track.js","../node_modules/mdast-util-math/lib/index.js","../node_modules/remark-math/index.js","../node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit-parents/lib/color.js","../node_modules/unist-util-visit-parents/lib/index.js","../node_modules/unist-util-visit/lib/index.js","../src/remark-math-to-code.js","../src/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownSpace} from 'micromark-util-character'\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `␉` represents a tab (plus how much it expands) and `␠` represents a\n * single space.\n *\n * ```markdown\n * ␉\n * ␠␠␠␠\n * ␉␠\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  return start\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n    if (sizeOpen < 2) {\n      return nok(code)\n    }\n    effects.exit('mathFlowFenceSequence')\n    return factorySpace(effects, metaBefore, 'whitespace')(code)\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code)\n    }\n    effects.enter('mathFlowFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('mathFlowFenceMeta')\n      return metaAfter(code)\n    }\n    if (code === 36) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence')\n    if (self.interrupt) {\n      return ok(code)\n    }\n    return effects.attempt(\n      nonLazyContinuation,\n      beforeNonLazyContinuation,\n      after\n    )(code)\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt(\n      {\n        tokenize: tokenizeClosingFence,\n        partial: true\n      },\n      after,\n      contentStart\n    )(code)\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (\n      initialSize\n        ? factorySpace(\n            effects,\n            beforeContentChunk,\n            'linePrefix',\n            initialSize + 1\n          )\n        : beforeContentChunk\n    )(code)\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code)\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeNonLazyContinuation,\n        after\n      )(code)\n    }\n    effects.enter('mathFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return beforeContentChunk(code)\n    }\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(\n      effects,\n      beforeSequenceClose,\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return sequenceClose(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n      if (size < sizeOpen) {\n        return nok(code)\n      }\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, afterSequenceClose, 'whitespace')(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code)\n    }\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can use two or more dollars for text math.\n\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport {markdownLineEnding} from 'micromark-util-character'\n/**\n * @param {Options | null | undefined} [options]\n * @returns {Construct}\n */\nexport function mathText(options) {\n  const options_ = options || {}\n  let single = options_.singleDollarTextMath\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this\n    let sizeOpen = 0\n    /** @type {number} */\n    let size\n    /** @type {Token} */\n    let token\n    return start\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText')\n      effects.enter('mathTextSequence')\n      return sequenceOpen(code)\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code)\n        sizeOpen++\n        return sequenceOpen\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code)\n      }\n      effects.exit('mathTextSequence')\n      return between(code)\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code)\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence')\n        size = 0\n        return sequenceClose(code)\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space')\n        effects.consume(code)\n        effects.exit('space')\n        return between\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        return between\n      }\n\n      // Data.\n      effects.enter('mathTextData')\n      return data(code)\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (\n        code === null ||\n        code === 32 ||\n        code === 36 ||\n        markdownLineEnding(code)\n      ) {\n        effects.exit('mathTextData')\n        return between(code)\n      }\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code)\n        size++\n        return sequenceClose\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence')\n        effects.exit('mathText')\n        return ok(code)\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData'\n      return data(code)\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n  let index\n  /** @type {number | undefined} */\n  let enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding'\n        events[headEnterIndex][1].type = 'mathTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'mathTextData'\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n      enter = undefined\n    }\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 36 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('./math-text.js').Options} Options\n */\n\nimport {mathFlow} from './math-flow.js'\nimport {mathText} from './math-text.js'\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  }\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {patternCompile} from 'mdast-util-to-markdown/lib/util/pattern-compile.js'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const tracker = track(safeOptions)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          before: value,\n          after: '\\n',\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n  function inlineMath(node, _, context) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index]\n      const expression = patternCompile(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n *\n * @typedef {import('mdast-util-math')} DoNotTouchAsThisImportIncludesMathInTree\n */\n\nimport {math} from 'micromark-extension-math'\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\n\n/**\n * Plugin to support math.\n *\n * @type {import('unified').Plugin<[Options?] | void[], Root, Root>}\n */\nexport default function remarkMath(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', math(options))\n  add('fromMarkdownExtensions', mathFromMarkdown())\n  add('toMarkdownExtensions', mathToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return '\\u001B[33m' + d + '\\u001B[39m'\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","import { visit } from 'unist-util-visit'\n\nexport const remarkMath2Code = () => {\n  return tree => {\n    visit(tree, { type: 'math' }, element => {\n      element.type = 'code'\n      element.lang = 'math'\n      element.data.hChildren = undefined\n      element.data.hName = undefined\n    })\n    visit(tree, { type: 'inlineMath' }, element => {\n      element.type = 'inlineCode'\n      element.lang = 'inline_math'\n      element.data.hChildren = undefined\n      element.data.hName = undefined\n      element.data.hProperties = {\n        lang: 'inline_math'\n      }\n    })\n  }\n}\n","import { markdownRenderer, CodeMirror } from 'inkdrop'\nimport { lazy } from 'react'\nimport remarkMath from 'remark-math'\nimport { remarkMath2Code } from './remark-math-to-code'\n\nconst MATH_MODE_INFO = {\n  name: 'math',\n  mime: 'text/x-latex',\n  mode: 'stex',\n  ext: [],\n  alias: ['inline_math']\n}\n\nconst ReactMath = lazy(() => import('./react-math'))\n\nmodule.exports = {\n  activate() {\n    if (markdownRenderer) {\n      markdownRenderer.remarkPlugins.push(remarkMath)\n      markdownRenderer.remarkPlugins.push(remarkMath2Code)\n      markdownRenderer.remarkCodeComponents.math = ReactMath\n      markdownRenderer.remarkCodeComponents.inline_math = ReactMath\n    }\n    if (CodeMirror) {\n      CodeMirror.modeInfo.push(MATH_MODE_INFO)\n    }\n  },\n\n  deactivate() {\n    if (markdownRenderer) {\n      markdownRenderer.remarkPlugins = markdownRenderer.remarkPlugins.filter(\n        plugin => remarkMath !== plugin\n      )\n      markdownRenderer.remarkPlugins = markdownRenderer.remarkPlugins.filter(\n        plugin => ![remarkMath, remarkMath2Code].includes(plugin)\n      )\n      markdownRenderer.remarkCodeComponents.math = null\n      markdownRenderer.remarkCodeComponents.inline_math = null\n    }\n    if (CodeMirror) {\n      const { modeInfo } = CodeMirror\n      const i = modeInfo.indexOf(MATH_MODE_INFO)\n      if (i >= 0) modeInfo.splice(i, 1)\n    }\n  }\n}\n"],"names":["markdownLineEnding","code","markdownSpace","factorySpace","effects","ok","type","max","limit","Number","POSITIVE_INFINITY","size","start","enter","prefix","consume","exit","mathFlow","tokenize","tokenizeMathFenced","concrete","nonLazyContinuation","tokenizeNonLazyContinuation","partial","nok","self","tail","events","length","initialSize","sliceSerialize","sizeOpen","sequenceOpen","metaBefore","metaAfter","contentType","meta","interrupt","attempt","beforeNonLazyContinuation","after","tokenizeClosingFence","contentStart","beforeContentChunk","contentChunk","beforeSequenceClose","parser","constructs","disable","null","includes","undefined","sequenceClose","afterSequenceClose","lineStart","lazy","now","line","mathText","options","options_","single","singleDollarTextMath","tokenizeMathText","resolve","resolveMathText","previous","token","between","data","tailExitIndex","headEnterIndex","index","end","splice","math","flow","text","longestStreak","value","substring","source","String","indexOf","expected","count","TypeError","patternCompile","pattern","_compiled","before","atBreak","RegExp","test","character","patternInScope","stack","listInScope","inConstruct","notInConstruct","list","none","safe","state","input","config","positions","result","infos","unsafe","expression","match","exec","Boolean","position","push","sort","numerical","escapeBackslashes","slice","charAt","encode","charCodeAt","toString","toUpperCase","join","a","b","results","whole","track","lineShift","column","move","current","shift","chunks","split","mathFromMarkdown","enterMathFlow","mathFlowFenceMeta","enterMathFlowMeta","enterMathText","exitMathFlow","mathFlowFence","exitMathFlowFence","exitMathFlowMeta","mathFlowValue","exitMathData","exitMathText","mathTextData","hName","hProperties","className","hChildren","buffer","resume","node","getData","setData","replace","call","mathToMarkdown","inlineMath","peek","inlineMathPeek","handlers","_","context","safeOptions","raw","tracker","sequence","repeat","Math","subexit","codePointAt","remarkMath","add","field","convert","typeFactory","Array","isArray","anyFactory","propsFactory","castFactory","Error","tests","checks","any","parameters","check","all","key","assertion","color","d","CONTINUE","EXIT","SKIP","visitParents","tree","visitor","reverse","is","step","factory","parents","name","tagName","Object","defineProperty","visit","subresult","offset","grandparents","toResult","children","concat","overload","parent","remarkMath2Code","element","lang","MATH_MODE_INFO","mime","mode","ext","alias","ReactMath","module","exports","activate","markdownRenderer","remarkPlugins","remarkCodeComponents","inline_math","CodeMirror","modeInfo","deactivate","filter","plugin","i"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}