{"version":3,"file":"index.js","sources":["../node_modules/micromark-util-character/index.js","../node_modules/micromark-factory-space/index.js","../node_modules/micromark-extension-math/lib/math-flow.js","../node_modules/micromark-extension-math/lib/math-text.js","../node_modules/micromark-extension-math/lib/syntax.js","../node_modules/longest-streak/index.js","../node_modules/remark-math/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../node_modules/remark-math/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/remark-math/node_modules/mdast-util-to-markdown/lib/util/safe.js","../node_modules/remark-math/node_modules/mdast-util-to-markdown/lib/util/track.js","../node_modules/remark-math/node_modules/mdast-util-math/lib/index.js","../node_modules/remark-math/index.js","../node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit-parents/lib/color.js","../node_modules/unist-util-visit-parents/lib/index.js","../node_modules/unist-util-visit/lib/index.js","../src/remark-math-to-code.js","../src/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownSpace} from 'micromark-util-character'\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `␉` represents a tab (plus how much it expands) and `␠` represents a\n * single space.\n *\n * ```markdown\n * ␉\n * ␠␠␠␠\n * ␉␠\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  return start\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n    if (sizeOpen < 2) {\n      return nok(code)\n    }\n    effects.exit('mathFlowFenceSequence')\n    return factorySpace(effects, metaBefore, 'whitespace')(code)\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code)\n    }\n    effects.enter('mathFlowFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('mathFlowFenceMeta')\n      return metaAfter(code)\n    }\n    if (code === 36) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence')\n    if (self.interrupt) {\n      return ok(code)\n    }\n    return effects.attempt(\n      nonLazyContinuation,\n      beforeNonLazyContinuation,\n      after\n    )(code)\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt(\n      {\n        tokenize: tokenizeClosingFence,\n        partial: true\n      },\n      after,\n      contentStart\n    )(code)\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (\n      initialSize\n        ? factorySpace(\n            effects,\n            beforeContentChunk,\n            'linePrefix',\n            initialSize + 1\n          )\n        : beforeContentChunk\n    )(code)\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code)\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeNonLazyContinuation,\n        after\n      )(code)\n    }\n    effects.enter('mathFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return beforeContentChunk(code)\n    }\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(\n      effects,\n      beforeSequenceClose,\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return sequenceClose(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n      if (size < sizeOpen) {\n        return nok(code)\n      }\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, afterSequenceClose, 'whitespace')(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code)\n    }\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can use two or more dollars for text math.\n\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport {markdownLineEnding} from 'micromark-util-character'\n/**\n * @param {Options | null | undefined} [options]\n * @returns {Construct}\n */\nexport function mathText(options) {\n  const options_ = options || {}\n  let single = options_.singleDollarTextMath\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this\n    let sizeOpen = 0\n    /** @type {number} */\n    let size\n    /** @type {Token} */\n    let token\n    return start\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText')\n      effects.enter('mathTextSequence')\n      return sequenceOpen(code)\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code)\n        sizeOpen++\n        return sequenceOpen\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code)\n      }\n      effects.exit('mathTextSequence')\n      return between(code)\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code)\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence')\n        size = 0\n        return sequenceClose(code)\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space')\n        effects.consume(code)\n        effects.exit('space')\n        return between\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        return between\n      }\n\n      // Data.\n      effects.enter('mathTextData')\n      return data(code)\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (\n        code === null ||\n        code === 32 ||\n        code === 36 ||\n        markdownLineEnding(code)\n      ) {\n        effects.exit('mathTextData')\n        return between(code)\n      }\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code)\n        size++\n        return sequenceClose\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence')\n        effects.exit('mathText')\n        return ok(code)\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData'\n      return data(code)\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n  let index\n  /** @type {number | undefined} */\n  let enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding'\n        events[headEnterIndex][1].type = 'mathTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'mathTextData'\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n      enter = undefined\n    }\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 36 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('./math-text.js').Options} Options\n */\n\nimport {mathFlow} from './math-flow.js'\nimport {mathText} from './math-text.js'\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  }\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {patternCompile} from 'mdast-util-to-markdown/lib/util/pattern-compile.js'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const tracker = track(safeOptions)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          before: value,\n          after: '\\n',\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n  function inlineMath(node, _, context) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index]\n      const expression = patternCompile(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n *\n * @typedef {import('mdast-util-math')} DoNotTouchAsThisImportIncludesMathInTree\n */\n\nimport {math} from 'micromark-extension-math'\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\n\n/**\n * Plugin to support math.\n *\n * @type {import('unified').Plugin<[Options?] | void[], Root, Root>}\n */\nexport default function remarkMath(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', math(options))\n  add('fromMarkdownExtensions', mathFromMarkdown())\n  add('toMarkdownExtensions', mathToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node’s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > 👉 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn’t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn’t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isn’t a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when it’s released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > 👉 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn’t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn’t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n","import { visit } from 'unist-util-visit'\n\nexport const remarkMath2Code = () => {\n  return tree => {\n    visit(tree, { type: 'math' }, element => {\n      element.type = 'code'\n      element.lang = 'math'\n      element.data.hChildren = undefined\n      element.data.hName = undefined\n      element.data.hProperties = {\n        lang: 'math'\n      }\n    })\n    visit(tree, { type: 'inlineMath' }, element => {\n      element.type = 'inlineCode'\n      element.lang = 'inline_math'\n      element.data.hChildren = undefined\n      element.data.hName = undefined\n      element.data.hProperties = {\n        lang: 'inline_math'\n      }\n    })\n  }\n}\n","import { markdownRenderer, CodeMirror } from 'inkdrop'\nimport { lazy } from 'react'\nimport remarkMath from 'remark-math'\nimport { remarkMath2Code } from './remark-math-to-code'\n\nconst MATH_MODE_INFO = {\n  name: 'math',\n  mime: 'text/x-latex',\n  mode: 'stex',\n  ext: [],\n  alias: ['inline_math']\n}\n\nconst ReactMath = lazy(() => import('./react-math'))\n\nmodule.exports = {\n  activate() {\n    if (markdownRenderer) {\n      markdownRenderer.remarkPlugins.push(remarkMath)\n      markdownRenderer.remarkPlugins.push(remarkMath2Code)\n      markdownRenderer.remarkCodeComponents.math = ReactMath\n      markdownRenderer.remarkCodeComponents.inline_math = ReactMath\n    }\n    if (CodeMirror) {\n      CodeMirror.modeInfo.push(MATH_MODE_INFO)\n    }\n  },\n\n  deactivate() {\n    if (markdownRenderer) {\n      markdownRenderer.remarkPlugins = markdownRenderer.remarkPlugins.filter(\n        plugin => remarkMath !== plugin\n      )\n      markdownRenderer.remarkPlugins = markdownRenderer.remarkPlugins.filter(\n        plugin => ![remarkMath, remarkMath2Code].includes(plugin)\n      )\n      markdownRenderer.remarkCodeComponents.math = null\n      markdownRenderer.remarkCodeComponents.inline_math = null\n    }\n    if (CodeMirror) {\n      const { modeInfo } = CodeMirror\n      const i = modeInfo.indexOf(MATH_MODE_INFO)\n      if (i >= 0) modeInfo.splice(i, 1)\n    }\n  }\n}\n"],"names":["markdownLineEnding","code","markdownSpace","factorySpace","effects","ok","type","max","limit","Number","POSITIVE_INFINITY","size","start","enter","prefix","consume","exit","mathFlow","tokenize","tokenizeMathFenced","concrete","nonLazyContinuation","tokenizeNonLazyContinuation","partial","nok","self","tail","events","length","initialSize","sliceSerialize","sizeOpen","sequenceOpen","metaBefore","metaAfter","contentType","meta","interrupt","attempt","beforeNonLazyContinuation","after","tokenizeClosingFence","contentStart","beforeContentChunk","contentChunk","beforeSequenceClose","parser","constructs","disable","null","includes","undefined","sequenceClose","afterSequenceClose","lineStart","lazy","now","line","mathText","options","options_","single","singleDollarTextMath","tokenizeMathText","resolve","resolveMathText","previous","token","between","data","tailExitIndex","headEnterIndex","index","end","splice","math","flow","text","longestStreak","value","substring","source","String","indexOf","expected","count","TypeError","patternCompile","pattern","_compiled","before","atBreak","RegExp","test","character","patternInScope","stack","listInScope","inConstruct","notInConstruct","list","none","safe","state","input","config","positions","result","infos","unsafe","expression","match","exec","Boolean","position","push","sort","numerical","escapeBackslashes","slice","charAt","encode","charCodeAt","toString","toUpperCase","join","a","b","results","whole","track","lineShift","column","move","current","shift","chunks","split","mathFromMarkdown","enterMathFlow","mathFlowFenceMeta","enterMathFlowMeta","enterMathText","exitMathFlow","mathFlowFence","exitMathFlowFence","exitMathFlowMeta","mathFlowValue","exitMathData","exitMathText","mathTextData","hName","hProperties","className","hChildren","buffer","resume","node","getData","setData","replace","call","mathToMarkdown","inlineMath","peek","inlineMathPeek","handlers","_","context","safeOptions","raw","tracker","sequence","repeat","Math","subexit","codePointAt","remarkMath","add","field","convert","castFactory","Array","isArray","anyFactory","propsFactory","typeFactory","Error","tests","checks","any","parameters","apply","check","checkAsRecord","all","nodeAsRecord","key","testFunction","parent","looksLikeANode","color","d","empty","CONTINUE","EXIT","SKIP","visitParents","tree","visitor","reverse","is","step","factory","parents","name","tagName","Object","defineProperty","visit","subresult","offset","grandparents","toResult","children","nodeAsParent","concat","child","testOrVisitor","visitorOrReverse","maybeReverse","overload","remarkMath2Code","element","lang","MATH_MODE_INFO","mime","mode","ext","alias","ReactMath","module","exports","activate","markdownRenderer","remarkPlugins","remarkCodeComponents","inline_math","CodeMirror","modeInfo","deactivate","filter","plugin","i"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}